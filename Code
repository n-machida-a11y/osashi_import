/**
 * @NotOnlyCurrentDoc
 */

/**
 * ■設定エリア
 */
const SPREADSHEET_ID = '1L2DgOm3gfEZMwoe2TDjzBJuq5cHB2SlBlwg6vifg5IE'; // 本番用ID
const ORDER_SHEET_NAME = '受注データ';
const DETAIL_SHEET_NAME = '受注明細';
const DELIVERY_MASTER_SHEET_NAME = '直送先マスタ';

// ■ゼロ落ちを防ぎたい（文字列として扱いたい）列名のリスト
// ここに含まれる列は、書き込み時に先頭に ' を付けて強制的に文字列とします
const TEXT_COLUMNS = [
  '受注No', '得意先コード', '直送先コード', '部門コード', '担当者コード', '摘要コード',
  'FM情報No', 'FM出荷No', '郵便番号', '会社TEL', '会社FAX',
  '伝票No', '統合先受注No', 'レンタルID',
  '商品コード', '倉庫コード', '計算式コード', 'ﾌﾟﾛｼﾞｪｸﾄコード', 'ロットNo'
];

// ■自動入力する数式の定義
// {ROW} → 行番号に置換
// {DELIVERY_CODE_COL} → 「直送先コード」のある列文字(Fなど)に置換
// {DELIVERY_NAME_COL} → 「直送先名」のある列文字(Gなど)に置換
const AUTO_FORMULAS = {
  '郵便番号': "=IFERROR(VLOOKUP(${DELIVERY_CODE_COL}{ROW},'直送先マスタ'!$A:$X,8),\"\")",
  '住所１': "=IFERROR(VLOOKUP(${DELIVERY_CODE_COL}{ROW},'直送先マスタ'!$A:$X,9),\"\")",
  '住所２': "=IFERROR(VLOOKUP(${DELIVERY_CODE_COL}{ROW},'直送先マスタ'!$A:$X,10),\"\")",
  '会社TEL': "=IFERROR(VLOOKUP(${DELIVERY_CODE_COL}{ROW},'直送先マスタ'!$A:$X,11),\"\")",
  '直送先コード_出荷明細': "=${DELIVERY_CODE_COL}{ROW}",
  '直送先名称_出荷明細': "=${DELIVERY_NAME_COL}{ROW}"
};

/**
 * WebアプリのGETリクエストを処理し、HTMLを表示する
 */
function doGet(e) {
  return HtmlService.createHtmlOutputFromFile('index')
    .setTitle('受注データ取込アプリ')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

/**
 * CSVデータを処理してスプレッドシートにマージ（更新・追加）する
 */
function processCsvData(csvData) {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(30000)) {
    return { status: 'error', message: '他のユーザーが処理中です。しばらく待ってから再実行してください。' };
  }

  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const orderSheet = ss.getSheetByName(ORDER_SHEET_NAME);
    const detailSheet = ss.getSheetByName(DETAIL_SHEET_NAME);
    const deliveryMasterSheet = ss.getSheetByName(DELIVERY_MASTER_SHEET_NAME);

    if (!orderSheet || !detailSheet || !deliveryMasterSheet) {
      throw new Error('指定されたシートが見つかりません。（受注データ、受注明細、直送先マスタ）');
    }

    // 1. 直送先マスタの読み込み（値補完用だが今回は数式メインなので補助的）
    const deliveryMasterMap = _createDeliveryMasterMap(deliveryMasterSheet);

    // 2. CSVデータのクリーニングとパース
    // 商魂データなどの場合、1行目にバージョン情報が入ることがあるため、ヘッダー行（受注Noを含む行）を探す
    const rawLines = csvData.replace(/\r\n/g, '\n').split('\n');
    let startIndex = -1;
    
    for (let i = 0; i < rawLines.length; i++) {
      // 行の中に「受注No」が含まれていれば、そこをヘッダー行とみなす
      if (rawLines[i].includes('受注No')) {
        startIndex = i;
        break;
      }
    }

    if (startIndex === -1) {
      throw new Error('CSVデータ内に「受注No」列が見つかりません。');
    }

    // ヘッダー行より前のゴミ行を削除してパース
    const validCsvData = rawLines.slice(startIndex).join('\n');
    const parsedData = Utilities.parseCsv(validCsvData);

    if (parsedData.length < 2) {
      throw new Error('CSVデータが空、またはヘッダーしかありません。');
    }

    const csvHeaders = parsedData[0].map(h => h.trim());
    const csvRows = parsedData.slice(1);

    // ★追加: デバッグ用チェック（CSVに必須列があるか）
    if (!csvHeaders.includes('受注No')) {
      throw new Error(`CSVファイルに「受注No」列が見つかりません。\n実際のヘッダー: [${csvHeaders.join(', ')}]`);
    }

    // ★追加: スプレッドシートのヘッダーチェック
    _checkSheetHeader(orderSheet, '受注No');
    _checkSheetHeader(detailSheet, '受注明細No');

    // 3. データ前処理
    const processedOrders = new Map();
    const processedDetails = [];
    const orderLineCounters = new Map(); 

    csvRows.forEach((rowArray) => {
      const rowObj = {};
      csvHeaders.forEach((header, i) => {
        let val = rowArray[i] || '';
        // ゼロ落ち対策: 文字列化
        if (TEXT_COLUMNS.includes(header)) {
          val = String(val).trim();
        }
        rowObj[header] = val;
      });

      const orderNo = rowObj['受注No'];
      // 受注Noがない行はスキップ
      if (!orderNo) return;

      // マスタ情報の補完（数式定義にない項目のみ値を埋める保険処理）
      const deliveryCode = rowObj['直送先コード'];
      if (deliveryCode && deliveryMasterMap.has(deliveryCode)) {
        const master = deliveryMasterMap.get(deliveryCode);
        // AUTO_FORMULASにある項目は数式で入るので、ここでは値をセットしない（数式を上書きしないようにする）
        if (!AUTO_FORMULAS['郵便番号']) rowObj['郵便番号'] = master.postalCode;
        if (!AUTO_FORMULAS['住所１']) rowObj['住所１'] = master.address1;
        if (!AUTO_FORMULAS['住所２']) rowObj['住所２'] = master.address2;
        if (!AUTO_FORMULAS['会社TEL']) rowObj['会社TEL'] = master.tel;
      }

      if (!processedOrders.has(orderNo)) {
        processedOrders.set(orderNo, rowObj);
      }

      let count = orderLineCounters.get(orderNo) || 0;
      count++;
      orderLineCounters.set(orderNo, count);
      
      rowObj['受注明細No'] = `${orderNo}-${count}`;
      processedDetails.push(rowObj);
    });

    if (processedOrders.size === 0) {
      return { status: 'error', message: 'CSVから有効なデータ（受注Noがある行）を読み取れませんでした。' };
    }

    // 4. マージ処理実行
    const orderResult = _mergeDataToSheet(orderSheet, Array.from(processedOrders.values()), '受注No');
    const detailResult = _mergeDataToSheet(detailSheet, processedDetails, '受注明細No');

    let warningMsg = "";
    if (orderResult.missingColumns.length > 0) warningMsg += `\n【受注データ】未反映列: ${orderResult.missingColumns.join(', ')}`;
    if (detailResult.missingColumns.length > 0) warningMsg += `\n【受注明細】未反映列: ${detailResult.missingColumns.join(', ')}`;

    return {
      status: 'success',
      ordersAdded: processedOrders.size,
      detailsAdded: processedDetails.length,
      message: warningMsg ? `完了しましたが、シートに列がないため一部スキップされました。${warningMsg}` : null
    };

  } catch (e) {
    console.error(e);
    return { status: 'error', message: e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * シートにヘッダー行があるか確認する
 */
function _checkSheetHeader(sheet, requiredColName) {
  const lastCol = sheet.getLastColumn();
  if (lastCol === 0) {
    throw new Error(`シート「${sheet.getName()}」が空です。1行目にヘッダー（列名）を入力してください。`);
  }
  const headers = sheet.getRange(1, 1, 1, lastCol).getValues()[0].map(h => String(h).trim());
  if (!headers.includes(requiredColName)) {
    throw new Error(`シート「${sheet.getName()}」の1行目に、必須列「${requiredColName}」が見つかりません。`);
  }
}

/**
 * シートにデータをマージ（更新・追加）する汎用関数
 */
function _mergeDataToSheet(sheet, dataList, keyColumnName) {
  if (dataList.length === 0) return { missingColumns: [] };

  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  
  // シートデータ取得
  const range = lastRow > 0 ? sheet.getRange(1, 1, lastRow, lastCol) : null;
  const sheetValues = range ? range.getValues() : [];
  
  // ヘッダー行のみの場合（データ行なし）の対応
  if (sheetValues.length === 0) {
     throw new Error(`シート「${sheet.getName()}」のヘッダーが読み取れません。`);
  }

  const sheetHeaders = sheetValues[0].map(h => String(h).trim());
  const keyIndex = sheetHeaders.indexOf(keyColumnName);

  if (keyIndex === -1) {
    throw new Error(`シート「${sheet.getName()}」にキー列「${keyColumnName}」が見つかりません。`);
  }

  // ★列位置の自動検出（数式の参照先用）
  const deliveryCodeIdx = sheetHeaders.indexOf('直送先コード');
  const deliveryNameIdx = sheetHeaders.indexOf('直送先名'); // CSVヘッダーに合わせて調整
  
  const deliveryCodeChar = deliveryCodeIdx !== -1 ? columnToLetter(deliveryCodeIdx + 1) : 'F'; 
  const deliveryNameChar = deliveryNameIdx !== -1 ? columnToLetter(deliveryNameIdx + 1) : 'G'; 

  // キーと行番号のマッピング
  const keyRowMap = new Map();
  for (let i = 1; i < sheetValues.length; i++) {
    const key = String(sheetValues[i][keyIndex]).trim();
    if (key) {
      keyRowMap.set(key, i);
    }
  }

  const newRows = [];
  let isSheetUpdated = false;
  const missingColumns = new Set(); 

  dataList.forEach(rowObj => {
    const key = String(rowObj[keyColumnName]).trim();
    
    // 更新・追加対象の全カラム（CSVデータ + 自動計算式）
    const updateColumns = new Set([...Object.keys(rowObj), ...Object.keys(AUTO_FORMULAS)]);

    if (keyRowMap.has(key)) {
      // --- 更新 ---
      const rowIndex = keyRowMap.get(key);
      const actualRow = rowIndex + 1;

      updateColumns.forEach(colName => {
        const colIdx = sheetHeaders.indexOf(colName);
        if (colIdx !== -1) {
          let newVal = "";

          // ★数式列の処理
          if (AUTO_FORMULAS[colName]) {
            newVal = AUTO_FORMULAS[colName]
              .replace(/\{ROW\}/g, actualRow)
              .replace(/\{DELIVERY_CODE_COL\}/g, deliveryCodeChar)
              .replace(/\{DELIVERY_NAME_COL\}/g, deliveryNameChar);
          } else {
            // 通常列
            newVal = String(rowObj[colName]);
            // ★ゼロ落ち対策: 対象列でかつ数値っぽい場合は ' を付与
            if (TEXT_COLUMNS.includes(colName) && newVal !== "" && /^[0-9]+$/.test(newVal)) {
               newVal = "'" + newVal;
            }
          }

          const currentVal = String(sheetValues[rowIndex][colIdx]);
          // 値が異なる場合のみ更新
          if (currentVal !== newVal) {
            sheetValues[rowIndex][colIdx] = newVal;
            isSheetUpdated = true;
          }
        } else {
          // シートに列がない場合
          if (AUTO_FORMULAS[colName] || (rowObj[colName] && rowObj[colName] !== '')) {
             missingColumns.add(colName);
          }
        }
      });

    } else {
      // --- 新規追加 ---
      const actualRow = sheetValues.length + newRows.length + 1; 
      const newRow = new Array(sheetHeaders.length).fill('');
      
      sheetHeaders.forEach((header, colIdx) => {
        if (AUTO_FORMULAS[header]) {
           // ★数式列
           newRow[colIdx] = AUTO_FORMULAS[header]
              .replace(/\{ROW\}/g, actualRow)
              .replace(/\{DELIVERY_CODE_COL\}/g, deliveryCodeChar)
              .replace(/\{DELIVERY_NAME_COL\}/g, deliveryNameChar);
        } else if (rowObj.hasOwnProperty(header)) {
           let val = String(rowObj[header]);
           // ★ゼロ落ち対策
           if (TEXT_COLUMNS.includes(header) && val !== "" && /^[0-9]+$/.test(val)) {
               val = "'" + val;
           }
           newRow[colIdx] = val;
        }
      });
      newRows.push(newRow);
    }
  });

  if (isSheetUpdated) {
    sheet.getRange(1, 1, sheetValues.length, sheetValues[0].length).setValues(sheetValues);
  }

  if (newRows.length > 0) {
    const startRow = sheetValues.length + 1;
    sheet.getRange(startRow, 1, newRows.length, newRows[0].length).setValues(newRows);
  }

  return { missingColumns: Array.from(missingColumns) };
}

/**
 * 直送先マスタシートを読み込み
 */
function _createDeliveryMasterMap(sheet) {
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return new Map();
  
  const values = sheet.getRange(1, 1, lastRow, sheet.getLastColumn()).getValues();
  const headers = values[0].map(h => String(h).trim());

  const codeIndex = headers.indexOf('直送先コード');
  const postalCodeIndex = headers.indexOf('郵便番号');
  const address1Index = headers.indexOf('住所１');
  const address2Index = headers.indexOf('住所２');
  const telIndex = headers.indexOf('会社TEL');

  if (codeIndex === -1) {
    console.warn('直送先マスタに「直送先コード」列が見つかりません。');
    return new Map();
  }

  const masterMap = new Map();
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const deliveryCode = String(row[codeIndex]).trim();
    if (deliveryCode) {
      masterMap.set(deliveryCode, {
        postalCode: postalCodeIndex > -1 ? row[postalCodeIndex] : '',
        address1: address1Index > -1 ? row[address1Index] : '',
        address2: address2Index > -1 ? row[address2Index] : '',
        tel: telIndex > -1 ? row[telIndex] : '',
      });
    }
  }
  return masterMap;
}

function columnToLetter(column) {
  let temp, letter = '';
  while (column > 0) {
    temp = (column - 1) % 26;
    letter = String.fromCharCode(temp + 65) + letter;
    column = (column - temp - 1) / 26;
  }
  return letter;
}
