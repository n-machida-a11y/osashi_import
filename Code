/**
 * ■設定エリア
 */
const SPREADSHEET_ID = '1L2DgOm3gfEZMwoe2TDjzBJuq5cHB2SlBlwg6vifg5IE';
const ORDER_SHEET_NAME = '受注データ';
const DETAIL_SHEET_NAME = '受注明細';

// 商魂CSVから上書き更新しても良い列名リスト
const SHOKON_UPDATE_COLUMNS = [
  '商品コード', 'マスター区分', '商品名', '倉庫コード', '入数', '箱数', '数量', 
  '単位', '単価', '受注金額', '原単価', '原価金額', '粗利益', '外税額', '内税額', 
  '税区分', '税込区分', '備考', '標準価格', '売単価', '売価金額', '規格・型番', 
  '色', 'ｻｲｽﾞ', '計算式コード', '税率', '伝票消費税額', 'ﾌﾟﾛｼﾞｪｸﾄコード'
];

/**
 * WebアプリのGETリクエストを処理
 */
function doGet(e) {
  return HtmlService.createHtmlOutputFromFile('index')
    .setTitle('受注データ取込アプリ')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

/**
 * 複数のCSV/TXTデータを処理してスプレッドシートに同期する
 * @param {string[]} csvDataArray - ファイル内容の配列
 */
function processCsvData(csvDataArray) {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(60000)) { // 複数ファイル処理のためロック時間を長めに設定
    return { status: 'error', message: '他のユーザーが処理中です。しばらく待ってから再実行してください。' };
  }

  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const detailSheet = ss.getSheetByName(DETAIL_SHEET_NAME);
    if (!detailSheet) throw new Error('受注明細シートが見つかりません。');

    const csvDataMap = new Map(); // 受注No => 明細行配列
    let totalDetailsProcessed = 0;

    // 1. 各ファイルの内容をパースしてMapに集約
    csvDataArray.forEach(csvData => {
      const rawLines = csvData.replace(/\r\n/g, '\n').split('\n');
      let startIndex = -1;
      for (let i = 0; i < rawLines.length; i++) {
        if (rawLines[i].includes('受注No')) { startIndex = i; break; }
      }
      if (startIndex === -1) return; // ヘッダーがないファイルはスキップ

      const validCsvData = rawLines.slice(startIndex).join('\n');
      const parsedData = Utilities.parseCsv(validCsvData);
      const csvHeaders = parsedData[0].map(h => h.trim());
      const csvRows = parsedData.slice(1);

      csvRows.forEach(rowArray => {
        const rowObj = {};
        csvHeaders.forEach((h, i) => rowObj[h] = rowArray[i] || '');
        const orderNo = rowObj['受注No'];
        if (!orderNo) return;
        
        if (!csvDataMap.has(orderNo)) csvDataMap.set(orderNo, []);
        csvDataMap.get(orderNo).push(rowObj);
        totalDetailsProcessed++;
      });
    });

    if (csvDataMap.size === 0) {
      throw new Error('有効な受注データが見つかりませんでした。');
    }

    // 2. 受注ごとに同期実行
    csvDataMap.forEach((rows, orderNo) => {
      _syncOrderDetails(detailSheet, orderNo, rows);
    });

    return {
      status: 'success',
      ordersAdded: csvDataMap.size,
      detailsAdded: totalDetailsProcessed, // undefined修正：明細総件数を返す
      message: `完了：受注データ${csvDataMap.size}件、受注明細${totalDetailsProcessed}件を同期しました。`
    };

  } catch (e) {
    console.error(e);
    return { status: 'error', message: e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * 特定の受注Noの明細を完全に同期する（前回提示のロジックを流用）
 */
function _syncOrderDetails(sheet, orderNo, csvRows) {
  const fullRange = sheet.getDataRange();
  const fullData = fullRange.getValues();
  const headers = fullData[0].map(h => String(h).trim());
  const colIdx = {
    detailNo: headers.indexOf('受注明細No'),
    orderNo: headers.indexOf('受注No'),
    shohinCode: headers.indexOf('商品コード')
  };

  const existingShokonRows = [];
  const manualRows = []; 
  
  for (let i = 1; i < fullData.length; i++) {
    const row = fullData[i];
    if (String(row[colIdx.orderNo]) !== String(orderNo)) continue;
    
    const dNo = String(row[colIdx.detailNo]);
    if (_isUuid(dNo)) {
      manualRows.push(row); 
    } else {
      existingShokonRows.push({ index: i, data: row, matched: false });
    }
  }

  const finalRows = [];
  const currentMaxNum = _getMaxSerial(existingShokonRows, orderNo);
  let newSerialCounter = currentMaxNum + 1;
  const occurrenceCountMap = new Map();

  csvRows.forEach(csvRow => {
    const sCode = csvRow['商品コード'];
    const count = (occurrenceCountMap.get(sCode) || 0) + 1;
    occurrenceCountMap.set(sCode, count);

    let match = _findMatch(existingShokonRows, sCode, count, colIdx.shohinCode);
    
    let targetRow;
    if (match) {
      match.matched = true;
      targetRow = [...match.data];
      SHOKON_UPDATE_COLUMNS.forEach(colName => {
        const idx = headers.indexOf(colName);
        if (idx !== -1) targetRow[idx] = csvRow[colName];
      });
    } else {
      targetRow = new Array(headers.length).fill('');
      headers.forEach((h, i) => {
        if (csvRow[h] !== undefined) targetRow[i] = csvRow[h];
      });
      targetRow[colIdx.detailNo] = `${orderNo}-${newSerialCounter++}`;
      targetRow[colIdx.orderNo] = orderNo;
    }
    finalRows.push(targetRow);
  });

  const otherOrdersRows = fullData.slice(1).filter(row => String(row[colIdx.orderNo]) !== String(orderNo));
  const newSheetData = [headers, ...otherOrdersRows, ...finalRows, ...manualRows];

  sheet.clearContents();
  sheet.getRange(1, 1, newSheetData.length, newSheetData[0].length).setValues(newSheetData);
}

function _isUuid(id) {
  if (!id) return false;
  return id.length > 20 && id.includes('-'); 
}

function _getMaxSerial(rows, orderNo) {
  let max = 0;
  rows.forEach(r => {
    const dNo = String(r.data[0]);
    const num = parseInt(dNo.replace(orderNo + '-', ''));
    if (!isNaN(num) && num > max) max = num;
  });
  return max;
}

function _findMatch(existingRows, shohinCode, occurrence, codeIdx) {
  let foundCount = 0;
  for (let row of existingRows) {
    if (String(row.data[codeIdx]) === String(shohinCode)) {
      foundCount++;
      if (foundCount === occurrence) return row;
    }
  }
  return null;
}
